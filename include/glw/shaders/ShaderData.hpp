
/**
 * This file is automatically generated.  Changes made to this file will
 * not be reflected after compiling.
 *
 * If you wish to make changes to shader information for Glr, edit the shaders
 * and shader programs in the 'data/shaders/' directory.
 *
 */
 
#include <map> 
 
namespace glr {

namespace shaders {

static std::map<std::string, std::string> SHADER_DATA = {

{"glr_gui.program", std::string(
	R"<STRING>(
#name glr_gui
#type program

#include "glr_gui.vert"
#include "glr_gui.frag"

)<STRING>"
)}	
, 
{"glr_basic.program", std::string(
	R"<STRING>(
#name glr_basic
#type program

#include "shader.vert"
#include "shader.frag"

)<STRING>"
)}	
, 
{"test.frag", std::string(
	R"<STRING>(
#version 150 core

#type fragment

in vec2 textureCoord;
in vec3 normalDirection;
in vec3 lightDirection;
in vec4 color;
in float bug;

void main() {
	gl_FragColor = color;
}

)<STRING>"
)}	
, 
{"glr_gui.vert", std::string(
	R"<STRING>(
#version 150 core

#type vertex

#include <glr>

in vec3 in_Position;
in vec2 in_Texture;
in vec3 in_Normal;

out vec2 textureCoord;
out vec3 normalDirection;
out vec3 lightDirection;

void main()
{
	gl_Position = pvmMatrix * vec4(in_Position, 1.0);
	
	textureCoord = in_Texture;

	normalDirection = normalize(normalMatrix * in_Normal);
	
	/*
	float bug = 0.0;	
	bvec3 result = equal( diffuseReflection, vec3(0.0, 0.0, 0.0) );
	if(result[0] && result[1] && result[2]) bug = 1.0;
	diffuseReflection.x += bug;
	*/
}

)<STRING>"
)}	
, 
{"shader.vert", std::string(
	R"<STRING>(
#version 150 core

#ifndef NUM_LIGHTS
#define NUM_LIGHTS 1
#endif

#ifndef MAX_BONES
#define MAX_BONES 100
#endif

#type vertex

#include <glr>
#include <light>

in vec3 in_Position;
in vec2 in_Texture;
in vec4 in_Color;
in vec3 in_Normal;
in ivec4 in_BoneIds;
in vec4 in_BoneWeights;

out vec2 textureCoord;
out vec3 normalDirection;
out vec3 lightDirection;
out vec4 color;
out float bug;

@bind Light
layout(std140) uniform Lights 
{
	Light lights[ NUM_LIGHTS ];
};

@bind Bone
layout(std140) uniform Bones 
{
	mat4 bones[ MAX_BONES ];
};

void main()
{
	// Calculate the transformation on the vertex position based on the bone weightings
	mat4 boneTransform = bones[ in_BoneIds[0] ] * in_BoneWeights[0];
    boneTransform     += bones[ in_BoneIds[1] ] * in_BoneWeights[1];
    boneTransform     += bones[ in_BoneIds[2] ] * in_BoneWeights[2];
    boneTransform     += bones[ in_BoneIds[3] ] * in_BoneWeights[3];
    
    // Temporary - this will cease all animation (and show just the model) - this works if you want to just show the model
    //mat4 tempM = mat4(1.0);
    //boneTransform = tempM;
    
    // This is for animating the model
    vec4 tempPosition = boneTransform * vec4(in_Position, 1.0);
	gl_Position = pvmMatrix * tempPosition;
	
	// Assign texture coordinates
	textureCoord = in_Texture;
	
	// Calculate normal
	vec4 normalDirTemp = boneTransform * vec4(in_Normal, 0.0);
	normalDirection = normalize(normalMatrix * normalDirTemp.xyz);
	//normalDirection = normalize(normalMatrix * in_Normal);
	
	// Calculate light direction
	vec4 lightDirTemp = viewMatrix * lights[0].direction;
	lightDirection = normalize(vec3(lightDirTemp));
	
	color = in_Color;
	
	
	// If we have any bugs, should highlight the vertex red or green
	bug = 0.0;
	float sum = in_BoneWeights[0] + in_BoneWeights[1] + in_BoneWeights[2] + in_BoneWeights[3];
	if (sum > 1.05f)
		bug = 1.0;
	else if (sum < 0.95f)
		bug = 2.0;
	//else if (in_BoneIds[0] > 32 || in_BoneIds[1] > 32 || in_BoneIds[2] > 32 || in_BoneIds[3] > 32)
	//	bug = 3.0;
	// disable bug highlighting
	//bug = 0.0;
	
	
	
	/*
	bvec4 result = equal( in_BoneIds, ivec4(0, 0, 0, 0) );
	if(result[0] && result[1] && result[2] && result[3])
		bug = 1.0;
	result = equal( in_BoneWeights, vec4(0.0, 0.0, 0.0, 0.0) );
	if(result[0] && result[1] && result[2] && result[3])
		bug = 2.0;
	*/
	
}

)<STRING>"
)}	
, 
{"material", std::string(
	R"<STRING>(
#type na
#name material

struct Material
{
	vec4 ambient;
	vec4 diffuse;
	vec4 specular;
	vec4 emission;
	//float shininess;
	//float strength;
};

)<STRING>"
)}	
, 
{"light", std::string(
	R"<STRING>(
#type na
#name light

struct Light
{
	vec4 ambient;
	vec4 diffuse;
	vec4 specular;
	vec4 position;
	vec4 direction;
};

)<STRING>"
)}	
, 
{"sky_box.vert", std::string(
	R"<STRING>(
#version 150 core

#type vertex

#include <glr>

in vec3 in_Position;
in vec2 in_Texture;
in vec4 in_Color;
in vec3 in_Normal;

out vec2 textureCoord;
out vec4 color;

void main()
{
	gl_Position = pvmMatrix * vec4(in_Position, 1.0);
	
	// Assign texture coordinates
	textureCoord = in_Texture;
	
	color = in_Color;
}

)<STRING>"
)}	
, 
{"sky_box.frag", std::string(
	R"<STRING>(
#version 150 core

#extension GL_EXT_texture_array : enable

#ifndef NUM_MATERIALS
#define NUM_MATERIALS 1
#endif

#type fragment

#include <material>

in vec2 textureCoord;
in vec4 color;

@bind Texture2D
uniform sampler2D tex2D;

@bind Material
layout(std140) uniform Materials 
{
	Material materials[ NUM_MATERIALS ];
};


void main()
{
	vec3 ct, cf;
	vec4 texel;
	float at, af;
 
	cf = (materials[0].diffuse).rgb + materials[0].ambient.rgb;
	af = materials[0].diffuse.a;
	texel = texture2D(tex2D, textureCoord);

	ct = texel.rgb;
	at = texel.a;

	gl_FragColor = vec4(ct * cf, at * af);
}

)<STRING>"
)}	
, 
{"glr_gui.frag", std::string(
	R"<STRING>(
#version 150 core

#extension GL_EXT_texture_array : enable

#type fragment

in vec2 textureCoord;
in vec3 normalDirection;

@bind Texture2D
uniform sampler2D tex2D;

void main()
{
	
	gl_FragColor = texture2D(tex2D, textureCoord);
	
	/*
	float bug = 0.0;	
	bvec4 result = equal( materials[0].diffuse, vec4(0.0, 0.0, 0.0, 0.0) );
	if(result[0] && result[1] && result[2]) bug = 1.0;
	gl_FragColor.x += bug;
	*/
}

)<STRING>"
)}	
, 
{"sky_box.program", std::string(
	R"<STRING>(
#name sky_box
#type program

#include "sky_box.vert"
#include "sky_box.frag"

)<STRING>"
)}	
, 
{"test.program", std::string(
	R"<STRING>(
#name test
#type program

#include "shader.vert"
#include "test.frag"

)<STRING>"
)}	
, 
{"shader.frag", std::string(
	R"<STRING>(
#version 150 core

#extension GL_EXT_texture_array : enable

#ifndef NUM_MATERIALS
#define NUM_MATERIALS 1
#endif

#type fragment

#include <material>

in vec2 textureCoord;
in vec3 normalDirection;
in vec3 lightDirection;
in vec4 color;
in float bug;

@bind Texture2D
uniform sampler2D tex2D;

//@bind Texture2DArray
//uniform sampler2DArray tex2DArray;

@bind Material
layout(std140) uniform Materials 
{
	Material materials[ NUM_MATERIALS ];
};


void main()
{
	vec3 ct, cf;
	vec4 texel;
	float intensity, at, af;
	intensity = max( dot(lightDirection, normalize(normalDirection)), 0.0 );
 
	cf = intensity * (materials[0].diffuse).rgb + materials[0].ambient.rgb;
	af = materials[0].diffuse.a;
	//texel = texture2DArray(tex2DArray, vec3(textureCoord, 1));
	texel = texture2D(tex2D, textureCoord);
 
	ct = texel.rgb;
	at = texel.a;
	
	gl_FragColor = vec4(ct * cf, at * af);
	
	
	
	// Show bugs
	if (bug != 0.0)
	{
		if (bug == 1.0)	
			gl_FragColor.x += bug;
		else if (bug == 2.0)	
			gl_FragColor.y += bug;
	}
	
	/*
	float bug = 0.0;	
	bvec4 result = equal( materials[0].diffuse, vec4(0.0, 0.0, 0.0, 0.0) );
	if(result[0] && result[1] && result[2]) bug = 1.0;
	gl_FragColor.x += bug;
	*/
}

)<STRING>"
)}	
, 
{"glr", std::string(
	R"<STRING>(
#type na
#name glr

uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat4 modelMatrix;
uniform mat4 pvmMatrix;
uniform mat3 normalMatrix;

)<STRING>"
)}	

};

}

}
