#! /bin/python
# Graphics Language Renderer (glr) SConstruct file
import subprocess, sys, os
import platform
import platform
import glob
import json
import shutil
import argparse
import multiprocessing







### Establish our system
isLinux = platform.system() == 'Linux'
isWindows = os.name == 'nt'
isMac = platform.system() == 'Darwin'

### Error check our platform type
if (not isLinux and not isWindows and not isMac):
	print("Sorry, but it appears your platform is not recognized")
	sys.exit(1)

def beautifyCode():
	fileList = []
	
	for r,d,f in os.walk("."):
		for files in f:
			if files.endswith(".h") or files.endswith(".cpp"):
				fileList.append( os.path.join(r,files) )
	
	
	for f in fileList:
		subprocess.call( shlex.split("uncrustify --mtime --no-backup -q -c xsupplicant.cfg "+f) )


def parseShadersIntoHeader():
	"""Parse the OpenGL Shader files into a single C++ Header file."""
	print('Parsing Shaders into header ShaderData.h')
	
	shaderDataOutputFilename = "ShaderData.h"
	shaderListLocation = "data/shaders/"
	#shaderListExtension = ".json"
	
	fileList = glob.glob( os.path.join(shaderListLocation, '*') )
	
	file = open(fileList[0], 'r')
	data = file.read()
	
	# Save json as a std::string in a .h file
	shaderDataFile = open( os.path.join('src/glw/shaders', shaderDataOutputFilename), 'w' )
	
	cpp = """
/**
 * This file is automatically generated.  Changes made to this file will
 * not be reflected after compiling.
 *
 * If you wish to make changes to shader information for Glr, edit the shaders
 * and shader programs in the 'data/shaders/' directory.
 *
 */
 
#include <map> 
 
namespace glr {

namespace shaders {

static std::map<std::string, std::string> SHADER_DATA = {
"""
	current = 0
	for filename in fileList:
		file = open(filename, 'r')
		data = file.read()
		
		if (current > 0):
			cpp += ", "
		
		cpp += """
{\""""

		filename = filename.replace(shaderListLocation, "")
		filename = filename.replace(".glsl", "")
		cpp += filename
		
		cpp +="""\", std::string(
	R"<STRING>(
"""

		cpp += data
		cpp += """
)<STRING>"
)}	
"""
		current += 1
	
	cpp += """
};

}

}
"""
		
	shaderDataFile.write(cpp)
	shaderDataFile.close()
	
	print('Done parsing Shaders into header ShaderData.h')

def compileGlr(compiler):
	os.chdir( '../glr' )
	return subprocess.Popen( 'scons compiler='+compiler, shell=True )

def clear():
	if (isWindows):
		os.system('cls')
	else:
		os.system('clear')

def clean():
	os.chdir( '../glr' )
	shutil.rmtree( './build', True )

def exitOnError(returnCode):
	if ( returnCode != 0):
		print( returnCode )
		print( "Script halted due to error(s)!" )
		sys.exit(1)




### Argument flags
doBeautification = False
doClean = False
compiler = ""

### Set our compiler
compiler = ARGUMENTS.get('compiler')
if (compiler is None or compiler == ''):
	compiler = 'default'
if (compiler == 'gcc' and isWindows):
	compiler = 'mingw'
if (compiler == 'msvc' and isWindows):
	compiler = 'default'

### Error check compiler
if (compiler == 'msvc' and not isWindows):
	print( "Cannot use msvc in this environment!" )
	sys.exit(1)

### Handle arguments
AddOption('--beautify', dest='beautify', action='store_true', help='will \'beautify\' the source code using uncrustify')
#AddOption('--clean', dest='clean', action='store_true', help='will \'beautify\' the source code using uncrustify')
#AddOption('--beautify', dest='beautify', type='string', nargs=1, action='store_true', help='will \'beautify\' the source code using uncrustify')





clear()
if (not isWindows):
	os.system( 'echo' )
	os.system( 'echo' )
	os.system( 'echo' )



if GetOption('beautify'):
	doBeautification = True
if GetOption('clean'):
	doClean = True


### Prepare code for comilation
if doBeautification:
	print("Beautifying Code")
	beautifyCode()
	print("Done")
	print("")

if (doClean):
	print("Cleaning glr build directory")
	clean();
	print("Done")





# Parse our shader programs and create .h files out of them
parseShadersIntoHeader()






cpp_paths = []
cpp_defines = []
cpp_flags = []
library_paths = []







# Tell SCons to create our build files in the 'build' directory
VariantDir('build', 'src', duplicate=0)

### Set our source files
source_files = Glob('build/*.cpp', 'build/*.h')

source_files = source_files + Glob('build/common/compatibility/*.cpp', 'build/common/compatibility/*.h')
source_files = source_files + Glob('build/common/math/*.cpp', 'build/common/math/*.h')
source_files = source_files + Glob('build/common/utilities/*.cpp', 'build/common/utilities/*.h')
source_files = source_files + Glob('build/common/io/*.cpp', 'build/common/io/*.h')
#source_files = source_files + Glob('build/vmath/*.cpp', 'build/vmath/*.h')

source_files = source_files + Glob('build/*.cpp', 'build/*.h')
source_files = source_files + Glob('build/exceptions/*.cpp', 'build/exceptions/*.h')
source_files = source_files + Glob('build/gui/*.cpp', 'build/gui/*.h')
source_files = source_files + Glob('build/models/*.cpp', 'build/models/*.h')

# OpenGL Wrapper stuff
source_files = source_files + Glob('build/glw/*.cpp', 'build/glw/*.h')
source_files = source_files + Glob('build/glw/shaders/*.cpp', 'build/glw/shaders/*.h')


cpp_paths = []
cpp_defines = []
cpp_flags = []
library_paths = []


### Set our required libraries
glLib = 'GL'
glewLib = 'GLEW'
berkeliumLib = 'liblibberkelium_d'
libPThread = 'pthread'
boostLogLib = 'boost_log'
boostLogSetupLib = 'boost_log_setup'
boostDateTimeLib = 'boost_date_time'
boostThreadLib = 'boost_thread'
boostWaveLib = 'boost_wave'
boostRegexLib = 'boost_regex'
boostFilesystemLib = 'boost_filesystem'
boostSystemLib = 'boost_system'

if (isWindows):
	glLib = 'opengl32'
	glewLib = 'glew32'
	berkeliumLib = 'berkelium'
	libPThread = ''
	boostLogLib = 'libboost_log-vc120-mt-1_55'
	boostLogSetupLib = 'libboost_log_setup-vc120-mt-1_55'
	boostDateTimeLib = 'libboost_date_time-vc120-mt-1_55'
	boostThreadLib = 'libboost_thread-vc120-mt-1_55'
	boostWaveLib = 'libboost_wave-vc120-mt-1_55'
	boostRegexLib = 'libboost_regex-vc120-mt-1_55'
	boostFilesystemLib = 'libboost_filesystem-vc120-mt-1_55'
	boostSystemLib = 'libboost_system-vc120-mt-1_55'

libraries = [
glLib,
glewLib,
berkeliumLib,
libPThread,
'sfml-system',
'sfml-window',
'assimp',
'freeimage',
boostLogLib,
boostLogSetupLib,
boostDateTimeLib, 
boostThreadLib,
boostWaveLib,
boostRegexLib,
boostFilesystemLib,
boostSystemLib
]

if (not isWindows):
	# XInput for linux
	libraries.append( 'Xi' )


### Set our general compiler variables
### Set our library paths
library_paths.append('../glr/build')
if (isWindows):
	library_paths.append('../../angelscript-sdk/angelscript/lib')
	library_paths.append('../../sqlite3')
	library_paths.append('../../berkelium-win32/lib')
	library_paths.append('../../SFML/lib')
	library_paths.append('C:\\Program Files\\Assimp\\lib\\x86')
	library_paths.append('C:\\Program Files (x86)\\Boost\\lib')
	library_paths.append('C:\\Users\\Jarrett\\projects\\FreeImage\\Dist')
	library_paths.append('C:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\VC\\lib')


# Set our g++ compiler flags
#'-D_GLIBCXX_DEBUG'

#debug = ARGUMENTS.get('debug', 0)
#if int(debug):
#	cpp_flags.append('-g')
#	cpp_defines.append('DEBUG')
#else:
#	cpp_defines.append('NDEBUG')
cpp_defines.append('DEBUG')	

cpp_defines.append( ('PACKAGE_VERSION', '\\"0.0.1\\"' ) )
cpp_defines.append( ('PACKAGE_BUGREPORT', '\\"https://github.com/jarrettchisholm/glr/issues\\"') )




### Set our OS specific compiler variables
if (not isWindows):
	if (compiler == 'gcc' or (compiler == 'default' and isLinux)):
		cpp_flags.append('-g')
		cpp_flags.append('-O0') # optimization level 0
		#cpp_flags.append('-pg') # profiler
		cpp_flags.append('-std=c++11')
		cpp_flags.append('-pedantic-errors')
		#cpp_flags.append('-Wall')
		#cpp_flags.append('-Wextra')
		#cpp_flags.append('-Werror')
		
	# Dynamically link to boost log
	cpp_defines.append('BOOST_LOG_DYN_LINK')
	
	# For some reason, on windows we need to use boost::phoenix version 3 with boost::log
	cpp_defines.append('BOOST_SPIRIT_USE_PHOENIX_V3')
else:
	if isWindows:
		if (compiler == 'default'):
			cpp_flags.append('/w') # disables warnings (Windows)
			cpp_flags.append('/wd4350') # disables the specific warning C4350
			cpp_flags.append('/EHsc') # Enable 'unwind semantics' for exception handling (Windows)
			cpp_flags.append('/MD')
		elif (compiler == 'mingw'):
			cpp_flags.append('-g')
			cpp_flags.append('-O0') # optimization level 0
			#cpp_flags.append('-pg') # profiler
			cpp_flags.append('-std=c++11')
			cpp_flags.append('-pedantic-errors')
		
		# For some reason, on windows we need to use boost::phoenix version 3 with boost::log
		cpp_defines.append('BOOST_SPIRIT_USE_PHOENIX_V3')
	
	
	#cpp_paths.append('C:\\Program Files (x86)\\Microsoft SDKs\\Windows\\v7.1A\\Include')
	#cpp_paths.append('C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include')
	
	cpp_paths.append('C:\\Program Files (x86)\\Boost\\include\\boost-1_55')
	cpp_paths.append('C:\\Program Files\\Assimp\\include')
	cpp_paths.append('C:\\Users\\Jarrett\\projects\\glm')
	cpp_paths.append('C:\\Users\\Jarrett\\projects\\FreeImage\\Dist')
	cpp_paths.append('C:\\Users\\Jarrett\\projects\\berkelium\\include')
	cpp_paths.append('C:\\Users\\Jarrett\\projects\\SFML\\include')



### Create our environment
env = Environment(ENV = os.environ, TOOLS = [compiler], CCFLAGS=[]) 

### Set our environment variables
env.Append( CPPFLAGS = cpp_flags )
env.Append( CPPDEFINES = cpp_defines )
env.Append( CPPPATH = cpp_paths )

env.SetOption('num_jobs', multiprocessing.cpu_count())



# Tell SCons the library to build
env.StaticLibrary('build/glr', source_files, LIBS = libraries, LIBPATH = library_paths)
