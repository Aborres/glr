
/**
 * This file is automatically generated.  Changes made to this file will
 * not be reflected after compiling.
 *
 * If you wish to make changes to shader information for Oglre, edit the shaders
 * and the shader program list in the 'data' directory.
 *
 */
 
#include <map> 
 
namespace oglre {

namespace shaders {

static std::map<std::string, std::string> SHADER_DATA = {

{"oglre.glsl", std::string(
	R"<STRING>(
#type na

uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat4 modelMatrix;
uniform mat4 pvmMatrix;
uniform mat3 normalMatrix;

	)<STRING>"
)}	
, 
{"shader.vert", std::string(
	R"<STRING>(
#version 150 core

#type vertex

#include <oglre>
#include <light>
#include <material>

in vec3 in_Position;
in vec2 in_Texture;
in vec3 in_Normal;

out vec2 textureCoord;
out vec4 pass_Color;

#bind Light
uniform LightSources {
	LightSource lightSources[1];
};

#bind Material
Material mymaterial = Material(
	vec4(1.0, 0.8, 0.8, 1.0),
	vec4(1.0, 0.8, 0.8, 1.0),
	vec4(1.0, 0.8, 0.8, 1.0),
	0.995
);


void main() {
	gl_Position = pvmMatrix * vec4(in_Position, 1.0);
	
	textureCoord = in_Texture;
	
	
	vec3 normalDirection = normalize(normalMatrix * in_Normal);
	vec3 lightDirection = normalize(vec3(lightSources[0].direction));
	
	vec3 diffuseReflection = vec3(lightSources[0].diffuse) * vec3(mymaterial.diffuse) * max(0.0, dot(normalDirection, lightDirection));
	
	/*
	float bug = 0.0;
	bvec3 result = equal( diffuseReflection, vec3(0.0, 0.0, 0.0) );
	if(result[0]) bug = 1.0;
	
	diffuseReflection.x += bug;
	*/
	
	pass_Color = vec4(diffuseReflection, 1.0);
}

	)<STRING>"
)}	
, 
{"material.glsl", std::string(
	R"<STRING>(
#type na

struct Material {
	vec4 ambient;
	vec4 diffuse;
	vec4 specular;
	float shininess;
};

	)<STRING>"
)}	
, 
{"light.glsl", std::string(
	R"<STRING>(
#type na

struct LightSource {
	vec4 ambient;
	vec4 diffuse;
	vec4 specular;
	vec4 position;
	vec4 direction;
};

	)<STRING>"
)}	
, 
{"shader_list.glsl.json", std::string(
	R"<STRING>(
{
	"programs": [{
			"name": "test",
			"shaders": [
				{ "name": "test_vertex_shader" },
				{ "name": "test_fragment_shader" }
			]
		}],
	
	"shaders": [
		{
			"name": "test_vertex_shader",
			"type": "vertex",
			"filename": "shader.vert",
			"variables": [
				{ 
					"in": [{
						"0": [ { "type": "vec3" }, { "name": "in_Position" } ],
						"1": [ { "type": "vec2" }, { "name": "in_Texture" } ],
						"2": [ { "type": "vec3" }, { "name": "in_Color" } ]
					}]
				},
				{ 
					"uniform": [{
						"0": [ { "type": "mat4" }, { "name": "projectionMatrix" } ],
						"1": [ { "type": "mat4" }, { "name": "viewMatrix" } ],
						"2": [ { "type": "mat4" }, { "name": "modelMatrix" } ]
					}]
				}
			]
		},
		
		{
			"name": "test_fragment_shader",
			"type": "fragment",
			"filename": "shader.frag"
		}
	]
}


{
	"program": [{
			"name": "test",
			"shaders": [
				{
					"name": "test_vertex_shader",
					"type": "vertex",
					"filename": "shader.vert",
					"contents": "blah blah"
				},
				{ "name": "fragment_shader" }
			]
		}],
}

	)<STRING>"
)}	
, 
{"shader.frag", std::string(
	R"<STRING>(
#version 150 core

#type fragment

#bind texture0
uniform sampler2D texture;

in vec4 pass_Color;
in vec2 textureCoord;

void main() {	
	vec4 out_Color = texture2D(texture, textureCoord);
	
	gl_FragColor = pass_Color;
	
	//gl_FragColor = out_Color;
}

	)<STRING>"
)}	
, 
{"oglre_basic.program", std::string(
	R"<STRING>(
#name oglre_basic
#type program

#include shader.vert
#include shader.frag

	)<STRING>"
)}	

};

}

}
